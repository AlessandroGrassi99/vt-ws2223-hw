# Virtualization Techniques WS 22/23 (Weidendorfer) Homework 2: Efficient Execution of Bytecode

## Tasks
### Task 1: Basic Interpretation
- [x] Define a data structure able to hold the machine state.
- [x] Write an interpreter for this ISA which is able to execute a program given as a byte array and a given machine state, returning at HALT.
- [x] Measure the average time required by your interpreter for executing one instruction, averaged across the input scenarios (generated by the C code, contained in `tests/gen`), both as absolute time and number of clock cycles.
- [x] What is the best timer source to use for measurement?
  - I am using `CLOCK_MONOTONIC` which represents the absolute elapsed wall-clock time since some arbitrary, fixed point in the past. It isn't affected by changes in the system time-of-day clock.
- [x] How to get clock cycles from time? (Hint: what is "turbo boost"?)
  - Relate the total clock cycles, to the total time required for a complete execution.
- [x] How to get stable measurement results?
  - It would be necessary to do a CPU warm-up, run the scenario multiple times, and extract the mean and standard deviation from the set of results.
- [ ] The difference in execution time between input scenarios 1 and 2 partly relates to branch prediction behavior. Using `perf state <interpreter>`, you can find out the number of branch mispredictions. How large is the cycle penalty of one misprediction for the CPU in your laptop on average?